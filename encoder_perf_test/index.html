<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>编码器性能对比</title>
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <style>
        /* ------------------------------------------------ */
        /* 全局主题样式 (保持不变) */
        /* ------------------------------------------------ */
        body { 
            /* 全局设置: Ubuntu 优先用于英文/数字，苹方 (PingFang SC) 用于中文 */
            font-family: 'Ubuntu', 'PingFang SC', 'Microsoft YaHei', Arial, sans-serif; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            margin: 20px auto; 
            background-color: #222222; 
            color: #E0E0E0;            
        }

         /* 返回主页按钮样式 */
        #homeButton {
            position: absolute; /* 绝对定位 */
            top: 20px;
            left: 20px;
            padding: 10px 15px;
            font-size: 0.9em;
            color: #e0e0e0; /* 保持与主页颜色一致 */
            background-color: #333333;
            border: 1px solid #778899;
            border-radius: 5px;
            text-decoration: none;
            transition: background-color 0.3s;
            z-index: 100; /* 确保按钮在最上层 */
        }
        
        /* 标题和描述 */
        h1 {
            color: #1a73e8;
            margin-bottom: 5px;
            text-align: center; 
        }
        p {
            color: #AAAAAA;
            margin-top: 10px;
            margin-bottom: 20px;
            text-align: center;
        }

        /* 全局控制按钮容器 */
        .global-controls {
            margin-top: 20px;
            margin-bottom: 20px;
            width: 90%;
            max-width: 1000px;
            text-align: center;
            /* 启用 Flex 布局来并排放置两个全局按钮 */
            display: flex;
            justify-content: center;
            gap: 20px; /* 按钮之间的间距 */
        }

        /* ------------------------------------------------ */
        /* 导航按钮样式 */
        /* ------------------------------------------------ */
        .nav-buttons-container {
            /* 让按钮居中显示，并在按钮容器上下增加间距 */
            display: flex;
            justify-content: center;
            gap: 20px; /* 按钮之间的间距 */
            margin: 0px auto 20px auto; 
            width: 100%;
            max-width: 960px;
        }

        .nav-button {
            /* 链接按钮的基本样式 */
            text-decoration: none;
            color: #E0E0E0; /* 文本颜色 */
            background-color: #333333; 
            border: 2px solid #505050;
            padding: 5px 3px;
            border-radius: 6px;
            font-weight: bold;
            font-size: 13px;
            width: 120px; 
            text-align: center; 
            display: inline-block; 
            transition: background-color 0.3s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.4);
        }

        .nav-button:hover {
            background-color: #444444; 
            border-color: #e0e0e0; 
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.6);
        }

        /* ------------------------------------------------ */
        /* 图表容器 (Canvas) 样式 - 固定网格高度 (保持不变) */
        /* ------------------------------------------------ */
        .chart-container { 
            width: 90%; 
            max-width: 960px; 
            margin-top: 30px; 
            margin-bottom: 10px; /* 减少底部边距，给图例留空间 */
            padding: 10px;
            background-color: #222222; 
            /* 图表四边加粗 */
            border: 3px solid #777777; 
            border-radius: 8px;
            box-sizing: border-box;
            
            /* 关键修改：固定图表 canvas 的宽高比为 1:1，以确保图表网格高度固定 */
            aspect-ratio: 1; 
        }

        /* ------------------------------------------------ */
        /* 自定义图例容器样式 - 满足固定 5 列的要求 (保持不变) */
        /* ------------------------------------------------ */
        .custom-legend-container {
            width: 90%;
            max-width: 960px;
            margin-top: 10px;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #222222;
            border: 3px solid #777777; /* 外部边框 */
            border-radius: 8px;
            box-sizing: border-box;
            
            /* 关键修改：使用 Grid 布局，固定 5 列等宽 */
            display: grid;
            grid-template-columns: repeat(5, 1fr); 
            gap: 8px;
        }

        .legend-item {
            cursor: pointer;
            display: flex;
            align-items: center;
            padding: 5px 8px;
            border-radius: 4px;
            background-color: #444444; /* 默认背景色 */
            transition: background-color 0.15s;
            text-overflow: ellipsis;
            white-space: nowrap;
            overflow: hidden;
            border: 1px solid transparent;
            font-size: 14px; /* 默认字体大小 */
        }
        
        .legend-item:hover {
            background-color: #666666;
        }
        

        .legend-item .color-box {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 6px;
            flex-shrink: 0;
            border-width: 2px;
            border-style: solid;
            box-sizing: border-box;
        }
        
        /* ------------------------------------------------ */
        /* 表格控制区样式 */
        /* ------------------------------------------------ */
        .controls-table-container {
            width: 90%;
            max-width: 1000px;
            /* 容器作为固定边框 */
            background-color: #333333; 
            border: 3px solid #777777; /* 固定的外部边框 */
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            /* 内部滚动 */
            overflow-x: auto; 
        }
        
        .controls-table {
            width: 100%;
            min-width: 700px; 
            border-collapse: collapse; 
            text-align: center;
            border: none; 
            table-layout: fixed; 
        }
        
        /* 默认单元格样式 */
        .controls-table th, .controls-table td {
            color: #E0E0E0;
            font-size: 14px; 
            border: 1px solid #555555; 
            vertical-align: middle;
            padding: 0; 
            height: 48px; 
            box-sizing: border-box; 
            background-color: #333333; 
            z-index: 1; 
        }
        
        /* 表头单元格 */
        .controls-table thead th {
            background-color: #444444; 
            font-weight: bold;
            height: auto; 
            padding: 10px 5px;
            z-index: 10; /* 确保表头在滚动时位于顶部 */
        }

        /* ------------------------------------------------ */
        /* 固定列样式 (左侧) (保持不变) */
        /* ------------------------------------------------ */
        .controls-table th:first-child, .controls-table td:first-child {
            width: 12%; 
            min-width: 100px;
            height: auto; 
            
            position: sticky;
            left: 0;
            z-index: 5; /* 确保固定列在滚动区域之上，并盖住边框 */
            
            /* 固定列背景色 */
            background-color: #444444; 
            
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.5); 
            padding: 8px; /* 文本居中显示所需的内边距 */
        }
        
        /* 表头第一列（左上角） */
        .controls-table th:first-child {
            background-color: #444444; 
            padding: 10px 5px;
            /* 左上角留空 */
        }

        /* 滚动区域的普通单元格 */
        .controls-table td:not(:first-child) {
            padding: 2px; /* 少量内边距 */
        }
        
        /* 行开关列 (最后一列) - 固定宽度 */
        .controls-table th:last-child {
            width: 8%;
            min-width: 80px;
        }
        /* 行开关列的父单元格  */
        .controls-table td:last-child {
            padding: 2px; 
        }
        
        /* ------------------------------------------------ */
        /* 交互式按钮样式 (统一间隙) (保持不变) */
        /* ------------------------------------------------ */

        /* 曲线组容器 (用于小按钮) */
        .cell-container {
            display: flex;
            flex-direction: row; 
            width: 100%;
            height: 100%; 
            min-height: 44px; 
            justify-content: stretch; 
            /* 统一外层留白和间隙 */
            gap: 4px; 
            padding: 2px; 
            box-sizing: border-box; 
        }

        /* “全部”按钮 */
        .toggle-cell-container {
            display: flex;
            flex-direction: row; 
            width: 100%;
            height: 100%; 
            min-height: 44px; 
            justify-content: stretch; 
            /* 统一外层留白和间隙 */
            gap: 4px; 
            padding: 2px; 
            box-sizing: border-box; 
        }
        
        /* 通用按钮样式 */
        .control-button, .toggle-all-btn, .global-btn {
            cursor: pointer;
            transition: background-color 0.15s ease, box-shadow 0.15s ease;
            user-select: none;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap; 
            font-size: 13px; /* PC 按钮字体大小 */
        }
        
        /* 曲线选择按钮 (小格子) */
        .control-button {
            flex-grow: 1; 
            flex-shrink: 1;
            flex-basis: 0; 

            padding: 8px 5px; 
            background-color: #4A4A4A; 
            color: #E0E0E0;
            border-radius: 4px; 
            height: 100%; 
            box-sizing: border-box; 
        }
        
        /* 行/列切换按钮 (全部) */
        .toggle-all-btn {
            /* 确保它填满容器 */
            flex-grow: 1;
            flex-shrink: 1;
            flex-basis: 0;

            color: white;
            background-color: #666666; 
            font-weight: bold;
            border-radius: 4px; 
            /* 内部内边距与小按钮保持一致 */
            padding: 8px 5px; 
            height: 100%;
            box-sizing: border-box;
        }
        
        /* 选中时的突出颜色 (蓝色 active) */
        .control-button.active, .toggle-all-btn.active, .global-btn.active {
            background-color: #1a73e8; 
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.4);
            font-weight: bold;
            color: white;
        }
        .control-button:hover:not(.active) { background-color: #666666; }
        .toggle-all-btn:hover:not(.active), .global-btn:hover:not(.active) { background-color: #888888; }
        
        /* 全局按钮 */
        .global-btn {
            min-height: 35px;
            width: 150px;
            display: flex; 
            margin: 0; 
            background-color: #666666;
            border-radius: 4px;
            font-size: 14px;
        }

        /* 颜色指示点 (模拟 Chart.js 点样式) */
        .color-indicator {
            display: inline-block;
            width: 10px; 
            height: 10px;
            border-radius: 50%;
            margin-left: 5px;
            flex-shrink: 0; 
            border-width: 2px; 
            border-style: solid;
            box-sizing: border-box;
        }

        /* 无数据单元格 */
        .no-data-cell {
            display: flex; 
            justify-content: center; 
            align-items: center; 
            width: 100%;
            height: 100%; 
            min-height: 44px; /* 与按钮高度匹配 */
            color: #888888;
            background-color: #333333; 
        }
        
        /* 无数据按钮样式 */
        .control-button.no-data {
            background-color: #333333;
            color: #888888;
            cursor: default;
        }
        .control-button.no-data:hover {
            background-color: #333333; 
        }
        .control-button.no-data .color-indicator {
            display: none; 
        }

        /* ------------------------------------------------ */
        /* 手机适配样式 (小于 768px 时激活) (保持不变) */
        /* ------------------------------------------------ */
        @media (max-width: 768px) {
            
            .controls-table {
                min-width: 500px; 
            }

            /* 1. 缩小行高 (单元格高度) */
            .controls-table th, .controls-table td {
                height: 30px; 
                font-size: 10px; 
            }

            /* 滚动区域单元格 padding */
            .controls-table td:not(:first-child) {
                padding: 1px;
            }

            /* 2. 确保内部元素高度同步缩小 */
            .cell-container, .toggle-cell-container, .no-data-cell {
                min-height: 28px; 
            }
            
            .control-button {
                font-size: 9px; 
                padding: 2px 1px; 
            }

            .toggle-all-btn {
                font-size: 9px;
                padding: 2px 1px; 
            }
            
            .cell-container, .toggle-cell-container {
                padding: 1px; 
                gap: 2px; 
            }

            /* 格式列和开关列宽度微调 */
            .controls-table th:first-child, .controls-table td:first-child {
                min-width: 60px; 
                padding: 2px; 
            }
            .controls-table th:last-child, .controls-table td:last-child {
                min-width: 50px;
                padding: 1px;
            }
            
            .color-indicator {
                width: 6px; 
                height: 6px;
                margin-left: 1px; 
                border-width: 1px; 
            }

            .global-controls {
                gap: 10px;
            }
            .global-btn {
                width: 100px;
                font-size: 12px;
            }

            /* 手机端图例字体和边距调整 */
            .custom-legend-container {
                grid-template-columns: repeat(3, 1fr); /* 手机端改为 3 列 */
                gap: 6px;
            }
            .legend-item {
                font-size: 11px;
            }
        }
    </style>
</head>
<body>

    <a href="../projects/" id="homeButton">← 返回上一级</a>

    <h1>编码器性能对比</h1>
    <p>
        使用表格矩阵控制区切换不同编码器和格式的 VMAF-码率曲线。<br>
        预设采用尽可能高质量的预设，具体预设可点击下方按钮查看。
    </p>
    
    <div class="nav-buttons-container">
            <a href="presets.html" class="nav-button">查看编码器参数</a>
            <a href="data.html" class="nav-button">查看数据</a>
        </div>

    <div class="controls-table-container">
        <table class="controls-table" id="controlsTable">
            </table>
    </div>

    <div class="global-controls">
        <button id="globalShowAllBtn" class="global-btn active">显示全部</button>
        <button id="toggleCrosshairBtn" class="global-btn">显示十字光标</button>
        <button id="saveImageBtn" class="global-btn">保存图片</button>
    </div>

    <div class="chart-container">
        <canvas id="rateVMAFChart"></canvas>
    </div>
    
    <div id="customLegendContainer" class="custom-legend-container"></div>

    <script>
        // -----------------------------------------------------------
        // 1. 数据配置 (保持不变)
        // -----------------------------------------------------------
        const rawData = {
            'x264': [
                { x: 2057, y: 62.637 }, { x: 4025, y: 76.806 }, { x: 7000, y: 85.771 }, { x: 10045, y: 89.596 }, 
                { x: 15237, y: 92.458 }, { x: 20045, y: 93.710 }, { x: 25282, y: 94.522 }, { x: 40142, y: 95.632 }, 
                { x: 60179, y: 96.408 }
            ],
            'H264_NVENC_9th': [
                { x: 2106, y: 63.551 }, { x: 4647, y: 75.720 }, { x: 6643, y: 83.885 }, { x: 10797, y: 89.340 }, 
                { x: 15038, y: 91.657 }, { x: 19090, y: 92.861 }, { x: 25210, y: 93.986 }, { x: 39528, y: 95.396 }, 
                { x: 59882, y: 96.426 }
            ],
            'x265': [
                { x: 2004, y: 82.283 }, { x: 4009, y: 88.265 }, { x: 6996, y: 91.640 }, { x: 10006, y: 93.249 }, 
                { x: 15353, y: 94.691 }, { x: 20078, y: 95.405 }, { x: 25149, y: 95.920 }, { x: 40243, y: 96.833 }, 
                { x: 60233, y: 97.519 }
            ],
            'HEVC_NVENC_7th': [
                { x: 2062, y: 75.633 }, { x: 4095, y: 82.730 }, { x: 7002, y: 89.227 }, { x: 10241, y: 91.435 }, 
                { x: 15469, y: 93.377 }, { x: 20113, y: 94.277 }, { x: 25094, y: 94.968 }, { x: 40068, y: 95.907 }, 
                { x: 60078, y: 96.750 }
            ],
            'HEVC_NVENC_8th': [
                { x: 2075, y: 75.456 }, { x: 3927, y: 83.246 }, { x: 7013, y: 89.164 }, { x: 10214, y: 91.572 }, 
                { x: 15516, y: 93.347 }, { x: 20033, y: 94.248 }, { x: 25076, y: 94.931 }, { x: 40111, y: 95.894 }, 
                { x: 60095, y: 96.780 }
            ],
            'HEVC_NVENC_9th': [
                { x: 1995, y: 76.643 }, { x: 3961, y: 82.819 }, { x: 6911, y: 89.518 }, { x: 10285, y: 91.811 }, 
                { x: 15473, y: 93.652 }, { x: 20068, y: 94.537 }, { x: 25008, y: 95.129 }, { x: 40020, y: 96.006 }, 
                { x: 60123, y: 96.818 }
            ],
            'HEVC_QSV_V8': [
                { x: 2010, y: 76.848 }, { x: 4020, y: 84.521 }, { x: 7008, y: 88.599 }, { x: 10075, y: 91.011 }, 
                { x: 15022, y: 93.028 }, { x: 20055, y: 94.029 }, { x: 25037, y: 94.772 }, { x: 40009, y: 96.277 }, 
                { x: 60150, y: 97.300 }
            ],
            'HEVC_QSV_V9': [
                { x: 2023, y: 79.333 }, { x: 4027, y: 86.360 }, { x: 7001, y: 90.200 }, { x: 10106, y: 92.120 },
                { x: 14997, y: 93.748 }, { x: 19999, y: 94.695 }, { x: 25045, y: 95.377 }, { x: 40099, y: 96.556 },
                { x: 59933, y: 97.431 }
            ], 
            'HEVC_AMF_3.1': [
                { x: 2003, y: 72.408 }, { x: 4011, y: 80.491 }, { x: 7010, y: 85.613 }, { x: 10013, y: 88.530 }, 
                { x: 15026, y: 91.022 }, { x: 20011, y: 92.421 }, { x: 25006, y: 93.341 }, { x: 40001, y: 94.934 }, 
                { x: 60074, y: 96.125 }
            ],
            'HEVC_AMF_4.0': [
                { x: 2010, y: 70.290 }, { x: 4010, y: 79.835 }, { x: 7014, y: 85.465 }, { x: 10019, y: 88.311 }, 
                { x: 15023, y: 90.811 }, { x: 20041, y: 92.318 }, { x: 25052, y: 93.344 }, { x: 40059, y: 95.026 }, 
                { x: 60063, y: 96.120 }
            ],
            'VP9_QSV_V8': [
                { x: 2046, y: 75.805 }, { x: 4010, y: 83.297 }, { x: 7020, y: 87.947 }, { x: 10279, y: 90.447 }, 
                { x: 15062, y: 92.513 }, { x: 20119, y: 93.790 }, { x: 24984, y: 94.628 }, { x: 39994, y: 96.217 }, 
                { x: 59976, y: 97.295 }
            ],
            'VP9_QSV_V9': [ 
                { x: 2056, y: 77.599 }, { x: 4014, y: 84.117 }, { x: 7029, y: 88.420 }, { x: 10286, y: 90.757 }, 
                { x: 15070, y: 92.733 }, { x: 20150, y: 93.950 }, { x: 24999, y: 94.785 }, { x: 40041, y: 96.253 }, 
                { x: 60020, y: 97.239 }
            ],
            'SVT-AV1': [
                { x: 2024, y: 86.677 }, { x: 4038, y: 91.279 }, { x: 7001, y: 93.714 }, { x: 10161, y: 94.946 }, 
                { x: 15053, y: 96.049 }, { x: 20061, y: 96.548 }, { x: 25148, y: 96.972 }, { x: 39969, y: 97.655 }, 
                { x: 60241, y: 98.038 }
            ],
            'AV1_NVENC_8th': [
                { x: 2066, y: 73.801 }, { x: 3809, y: 84.905 }, { x: 7063, y: 89.948 }, { x: 10168, y: 91.935 }, 
                { x: 15282, y: 93.580 }, { x: 20080, y: 94.544 }, { x: 25168, y: 95.237 }, { x: 40137, y: 96.402 }, 
                { x: 60193, y: 97.232 }
            ],
            'AV1_NVENC_9th': [
                { x: 2037, y: 75.010 }, { x: 3522, y: 85.185 }, { x: 7022, y: 90.970 }, { x: 10104, y: 92.819 }, 
                { x: 15283, y: 94.468 }, { x: 20238, y: 95.351 }, { x: 25070, y: 95.891 }, { x: 40149, y: 96.929 }, 
                { x: 60086, y: 97.644 }
            ],
            'AV1_QSV_V9': [
                { x: 2026, y: 78.035 }, { x: 4061, y: 85.069 }, { x: 7061, y: 89.175 }, { x: 10035, y: 91.117 }, 
                { x: 15000, y: 92.825 }, { x: 20011, y: 93.849 }, { x: 25126, y: 94.536 }, { x: 40168, y: 95.825 }, 
                { x: 59993, y: 96.769 }
            ],
            'AV1_AMF_4.0': [
                { x: 2017, y: 71.295 }, { x: 4020, y: 79.994 }, { x: 7025, y: 86.304 }, { x: 10040, y: 89.337 }, 
                { x: 15010, y: 91.711 }, { x: 19582, y: 92.928 }, { x: 25172, y: 93.813 }, { x: 40096, y: 95.210 }, 
                { x: 60105, y: 96.413 }
            ],
            'VVenC': [
                { x: 2047, y: 84.730 }, { x: 4059, y: 89.848 }, { x: 7004, y: 92.558 }, { x: 10017, y: 94.014 }, 
                { x: 15112, y: 95.421 }, { x: 20379, y: 96.058 }, { x: 25074, y: 96.441 }, { x: 39799, y: 97.083 },
                { x: 58295, y: 97.613 }
            ],
            '哔哩哔哩': [
                { x: 19118, y: 94.274 } 
            ]
        };

        // -----------------------------------------------------------
        // 2. 颜色主题配置 (保持不变)
        // -----------------------------------------------------------
        
        const COLOR_MAP = {
            /* ------------------- CPU 软件编码 ------------------- */
            'x264':    '#666633', 'x265':    '#FFD700', 'SVT-AV1': '#FF0000', 'VVenC':   '#99FF66',
            /* ------------------- NVENC (绿色系) ------------------- */
            'H264_NVENC_9th': '#808000', 
            'HEVC_NVENC_7th': '#00FFFF', 'HEVC_NVENC_8th': '#40E0D0', 'HEVC_NVENC_9th': '#20B2AA', 
            'AV1_NVENC_8th':  '#ADFF2F', 'AV1_NVENC_9th':  '#9ACD32', 
            /* ------------------- QSV (亮蓝色系) ------------------- */
            'HEVC_QSV_V8': '#1E90FF', 
            'HEVC_QSV_V9': '#6495ED', 
            'VP9_QSV_V8':  '#00BFFF',    
            'VP9_QSV_V9':  '#4169E1', 'AV1_QSV_V9':  '#0000CD',    
            /* ------------------- AMF (红橙色系) ------------------- */
            'HEVC_AMF_3.1': '#FF6347', 'HEVC_AMF_4.0': '#FF8C00', 'AV1_AMF_4.0':  '#FF7F50',   
            /* ------------------- 流媒体 ------------------- */
            '哔哩哔哩': '#00A2E8' 
        };

        const ENCODER_MATRIX = {
            'H.264': { 'CPU': ['x264'], 'NVENC': ['H264_NVENC_9th'], 'QSV': [], 'AMF': [], '流媒体': [] }, 
            'H.265': { 'CPU': ['x265'], 'NVENC': ['HEVC_NVENC_7th', 'HEVC_NVENC_8th', 'HEVC_NVENC_9th'], 'QSV': ['HEVC_QSV_V8', 'HEVC_QSV_V9'], 'AMF': ['HEVC_AMF_3.1', 'HEVC_AMF_4.0'], '流媒体': ['哔哩哔哩'] },
            'VP9': { 'CPU': [], 'NVENC': [], 'QSV': ['VP9_QSV_V8', 'VP9_QSV_V9'], 'AMF': [], '流媒体': [] },
            'AV1': { 'CPU': ['SVT-AV1'], 'NVENC': ['AV1_NVENC_8th', 'AV1_NVENC_9th'], 'QSV': ['AV1_QSV_V9'], 'AMF': ['AV1_AMF_4.0'], '流媒体': [] },
            'H.266': { 'CPU': ['VVenC'], 'NVENC': [], 'QSV': [], 'AMF': [], '流媒体': [] }
        };

        const COLUMN_HEADERS = ['CPU', 'NVENC', 'QSV', 'AMF', '流媒体'];
        const ROW_HEADERS = Object.keys(ENCODER_MATRIX);

        /**
         * 获取简化名称。
         */
        function getSimplifiedName(label) {
            if (label === 'x264' || label === 'x265' || label === 'SVT-AV1' || label === 'VVenC') return label;
            if (label === '哔哩哔哩') return 'BiliBili';

            if (label.includes('_NVENC_')) {
                return label.split('_').pop(); 
            }

            if (label.includes('_QSV_V')) {
                const match = label.match(/_(V\d+\.?\d*)$/); 
                if (match) return match[1];
            }

            if (label.includes('_AMF_')) {
                const parts = label.split('_');
                const version = parts.pop();
                if (version.includes('.')) return version;
                return version;
            }
            
            return label; 
        }

        /** 将 hex/rgb 颜色转换为 rgba(r,g,b,alpha) 格式 */
        function toRgba(color, alpha = 0.5) {
            if (color.startsWith('rgb(')) {
                return color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
            }
            if (color.startsWith('#')) {
                let r = 0, g = 0, b = 0;
                if (color.length === 4) {
                    r = parseInt(color[1] + color[1], 16);
                    g = parseInt(color[2] + color[2], 16);
                    b = parseInt(color[3] + color[3], 16);
                } else if (color.length === 7) {
                    r = parseInt(color.substring(1, 3), 16);
                    g = parseInt(color.substring(3, 5), 16);
                    b = parseInt(color.substring(5, 7), 16);
                }
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }
            return `rgba(128, 128, 128, ${alpha})`; 
        }

         /** 格式化数字，添加千位分隔符 (逗号)。 */
        function formatNumberWithCommas(number) {
            return Math.round(number).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        }

        // -----------------------------------------------------------
        // 3. Chart.js 数据集配置 (保持不变)
        // -----------------------------------------------------------

        const CHART_FONT_FAMILY = "'Ubuntu', 'PingFang SC', 'Microsoft YaHei', Arial, sans-serif";
        const PC_TICK_SIZE = 16;
        const MOBILE_TICK_SIZE = 12; 
        const PC_TITLE_SIZE = 18;
        const MOBILE_TITLE_SIZE = 14; 
        const PC_POINT_RADIUS = 4;
        const MOBILE_POINT_RADIUS = 2.5; 
        const PC_BORDER_WIDTH = 2;
        const MOBILE_BORDER_WIDTH = 1.5;

        // 获取当前尺寸的参数
        function getChartParams() {
            return window.innerWidth <= 768 ? {
                tickSize: MOBILE_TICK_SIZE,
                titleSize: MOBILE_TITLE_SIZE,
                pointRadius: MOBILE_POINT_RADIUS,
                borderWidth: MOBILE_BORDER_WIDTH
            } : {
                tickSize: PC_TICK_SIZE,
                titleSize: PC_TITLE_SIZE,
                pointRadius: PC_POINT_RADIUS,
                borderWidth: PC_BORDER_WIDTH
            };
        }


        // 初始化数据集 
        const initialParams = getChartParams();
        const chartDatasets = Object.keys(rawData).map((label) => {
            const color = COLOR_MAP[label];
            const isSinglePoint = label === '哔哩哔哩';

            return {
                label: label,
                data: rawData[label],
                // 直接使用初始参数设置样式
                borderColor: color, 
                backgroundColor: toRgba(color, 0.5), 
                pointRadius: initialParams.pointRadius,               
                tension: 0.4,                
                borderWidth: initialParams.borderWidth,
                showLine: !isSinglePoint,    
                hidden: false,               
                datasetIndex: -1,            
                simplifiedName: getSimplifiedName(label),
                color: color 
            };
        });

        chartDatasets.forEach((dataset, index) => {
            dataset.datasetIndex = index;
        });

        let rateVMAFChart;

        // -----------------------------------------------------------
        // 4. 十字光标插件 (仅负责绘制) (保持不变)
        // -----------------------------------------------------------
        const crosshairPlugin = {
            id: 'customCrosshair',
            afterDraw: (chart, args, options) => {
                if (!options.enabled || !chart.crosshairCoords) return;

                const currentParams = getChartParams();
                const { ctx } = chart;
                const { x, y } = chart.crosshairCoords;
                const chartArea = chart.chartArea;
                
                // 检查鼠标是否在绘图区域内
                if (x < chartArea.left || x > chartArea.right || y < chartArea.top || y > chartArea.bottom) {
                    return;
                }

                ctx.save();
                ctx.beginPath();
                
                // 绘制垂直虚线 (X 轴)
                ctx.strokeStyle = options.lineColor;
                ctx.lineWidth = options.lineWidth;
                ctx.setLineDash(options.lineDash);
                ctx.moveTo(x, chartArea.top);
                ctx.lineTo(x, chartArea.bottom);
                
                // 绘制水平虚线 (Y 轴)
                ctx.moveTo(chartArea.left, y);
                ctx.lineTo(chartArea.right, y);
                ctx.stroke();

                // 修复：重置线型，确保标签框描边为实线
                ctx.setLineDash([]); 
                
                // 计算坐标轴上的值
                const xScale = chart.scales.x;
                const yScale = chart.scales.y;
                const xValue = xScale.getValueForPixel(x);
                const yValue = yScale.getValueForPixel(y);
                
                // 绘制坐标值标签
                const drawCoordLabel = (value, scale, coord, isX) => {
                    // 格式化数值 (X轴取整，Y轴取三位小数)
                    const labelText = isX ? formatNumberWithCommas(value) : `${value.toFixed(3)}`; 
                    const fontSize = currentParams.tickSize;
                    const labelColor = options.labelColor; 
                    const bgColor = options.labelBgColor;   
                    
                    ctx.font = `${fontSize}px ${CHART_FONT_FAMILY}`;
                    ctx.textBaseline = 'middle'; 
                    
                    const textWidth = ctx.measureText(labelText).width;
                    const padding = 5;
                    const boxWidth = textWidth + 2 * padding;
                    const boxHeight = fontSize + 2 * padding;
                    
                    ctx.fillStyle = bgColor;
                    ctx.strokeStyle = labelColor; 
                    ctx.lineWidth = 1;

                    if (isX) {
                        // X轴 (底部)
                        const boxX = coord - boxWidth / 2;
                        const boxY = scale.top; 
                        
                        ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
                        ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
                        
                        ctx.fillStyle = labelColor;
                        ctx.fillText(labelText, coord - textWidth / 2, boxY + boxHeight / 2); 
                    } else {
                        // Y轴 (左侧)
                        const boxX = scale.right - boxWidth;
                        const boxY = coord - boxHeight / 2;
                        
                        ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
                        ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
                        
                        ctx.fillStyle = labelColor;
                        ctx.fillText(labelText, boxX + padding, boxY + boxHeight / 2); 
                    }
                };

                // 绘制 X 轴标签
                drawCoordLabel(xValue, xScale, x, true);

                // 绘制 Y 轴标签
                drawCoordLabel(yValue, yScale, y, false);
                
                ctx.restore();
            }
        };
        
        // -----------------------------------------------------------
        // 5. 外部事件监听 (处理实时鼠标坐标，确保过滤生效) (保持不变)
        // -----------------------------------------------------------

        function addCrosshairEvents(chart) {
            const canvas = chart.canvas;
            
            const mouseMoveHandler = (event) => {
                const pos = Chart.helpers.getRelativePosition(event, chart);
                
                // 1. 始终存储实时鼠标坐标 (Filter callback 依赖于此)
                chart.crosshairCoords = { x: pos.x, y: pos.y };

                if (chart.options.plugins.customCrosshair.enabled) {
                    // 启用十字光标：只画线，强制重绘，隐藏 Tooltip
                    chart.draw(); 
                } 
                // 2. 关键：当十字光标禁用时，我们不再调用 setActiveElements/update()，
                // 而是让 Chart.js 自身的事件处理逻辑来高效地管理 Tooltip。
            };
            
            const mouseOutHandler = () => {
                // 鼠标移出图表区域时，始终清理坐标
                chart.crosshairCoords = null; 

                if (chart.options.plugins.customCrosshair.enabled) {
                    // 启用十字光标时，重绘以清除十字线
                    chart.draw();
                } else {
                    // 禁用十字光标时，强制隐藏 Tooltip
                    chart.setActiveElements([]);
                    chart.update();
                }
            };
            
            // 绑定事件
            canvas.addEventListener('mousemove', mouseMoveHandler);
            canvas.addEventListener('mouseout', mouseOutHandler);
        }

        // 渲染并更新自定义图例 (保持不变)
        function renderCustomLegend() {
            const container = document.getElementById('customLegendContainer');
            if (!container || !rateVMAFChart) return;

            // 清空现有内容
            container.innerHTML = ''; 

            chartDatasets.forEach(dataset => {
                // 仅包含有数据的曲线
                if (dataset.data.length === 0) return; 

                const item = document.createElement('div');
                item.className = 'legend-item';
                item.dataset.index = dataset.datasetIndex;
                
                // 1. 设置可见性状态
                const isVisible = rateVMAFChart.isDatasetVisible(dataset.datasetIndex);
                
                // **核心修改：如果不可见，直接设置 display: none 使图例项消失**
                if (!isVisible) {
                    item.style.display = 'none'; 
                }

                // 2. 颜色方块
                const colorBox = document.createElement('span');
                colorBox.className = 'color-box';
                // 使用 datasets 的颜色
                colorBox.style.backgroundColor = dataset.backgroundColor; 
                colorBox.style.borderColor = dataset.color; 
                
                // 3. 标签文本
                const labelText = document.createElement('span');
                labelText.textContent = dataset.label;
                
                item.appendChild(colorBox);
                item.appendChild(labelText);
                
                // 4. 点击事件
                item.addEventListener('click', function() {
                    const index = parseInt(this.dataset.index);
                    const isCurrentlyVisible = rateVMAFChart.isDatasetVisible(index);
                    
                    rateVMAFChart.setDatasetVisibility(index, !isCurrentlyVisible);
                    rateVMAFChart.update();
                    
                    // 重新渲染图例以更新状态
                    renderCustomLegend(); 
                    
                    // 确保表格中的按钮状态也同步更新
                    const individualBtn = document.querySelector(`.control-button[data-index="${index}"]`);
                    if (individualBtn) {
                        individualBtn.classList.toggle('active', !isCurrentlyVisible);
                    }
                });

                container.appendChild(item);
            });
        }


        // Tooltip 过滤阈值
        const VMAF_DISTANCE_THRESHOLD = 2.0; 
        const RATE_DISTANCE_THRESHOLD = 1000; // Kbps

        function initializeChart() {
            const currentParams = getChartParams();
            const canvas = document.getElementById('rateVMAFChart');
            const ctx = canvas.getContext('2d');
            
            // 解决 Chart.js canvas 模糊问题：设置 Chart.js 的设备像素比为 4
            Chart.defaults.devicePixelRatio = 4; // 设置为4倍，与html2canvas的scale一致
            // 重置 canvas 元素，确保新的 devicePixelRatio 生效
            canvas.width = canvas.clientWidth * Chart.defaults.devicePixelRatio;
            canvas.height = canvas.clientHeight * Chart.defaults.devicePixelRatio;
            ctx.scale(Chart.defaults.devicePixelRatio, Chart.defaults.devicePixelRatio);

            rateVMAFChart = new Chart(ctx, {
                type: 'scatter', 
                data: { datasets: chartDatasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: true, 
                    aspectRatio: 1, 
                    layout: {
                        padding: {
                            right: 50 // 将右侧内边距设置为 40px
                        }
                    },
                    plugins: { 
                        // 禁用内置图例，使用自定义 HTML 图例
                        legend: { 
                            display: false, 
                        }, 
                        title: { display: false },
                        tooltip: {
                            // 使用回调函数进行双轴过滤
                            callbacks: {
                                filter: function(tooltipItem, index, tooltipItems, chart) {
                                    // 1. 获取实时鼠标位置 (由外部事件监听器捕获)
                                    const mouseCoords = chart.crosshairCoords;
                                    if (!mouseCoords) {
                                        // 如果鼠标不在图表区域，不显示 tooltip
                                        return false;
                                    }

                                    const xScale = chart.scales.x;
                                    const yScale = chart.scales.y;

                                    // 将鼠标的像素位置转换为数据值 (实时鼠标位置)
                                    const mouseRate = xScale.getValueForPixel(mouseCoords.x);
                                    const mouseVMAF = yScale.getValueForPixel(mouseCoords.y);
                                    
                                    // 2. 获取数据点的 X/Y 值
                                    const pointRate = tooltipItem.parsed.x;
                                    const pointVMAF = tooltipItem.parsed.y;
                                    
                                    // 3. 计算双轴差值
                                    const rateDifference = Math.abs(pointRate - mouseRate);
                                    const vmafDifference = Math.abs(pointVMAF - mouseVMAF);
                                    
                                    // 4. 应用双重限制：只有当码率和 VMAF 都在阈值内时才显示
                                    const isVmafClose = vmafDifference <= VMAF_DISTANCE_THRESHOLD;
                                    const isRateClose = rateDifference <= RATE_DISTANCE_THRESHOLD;

                                    // 只有当命中点满足这两个条件时，才返回 true
                                    return isVmafClose && isRateClose;
                                }
                            }
                        },
                        customCrosshair: {
                            enabled: false,
                            lineColor: '#BBBBBB', 
                            lineWidth: 1,
                            lineDash: [5, 5],
                            labelColor: 'white', 
                            labelBgColor: '#1a73e8' 
                        }
                    },
                    interaction: {
                        mode: 'point', 
                        intersect: false, 
                        axis: 'xy'
                    },
                    scales: {
                        x: { 
                            type: 'linear', 
                            title: { 
                                display: true, 
                                text: '平均码率/Kbps', 
                                color: '#E0E0E0', 
                                font: { 
                                    size: currentParams.titleSize, 
                                    family: CHART_FONT_FAMILY 
                                } 
                            }, 
                            // 横坐标最大值改为 70000
                            min: 0,
                            max: 70000, 
                            ticks: { 
                                color: '#E0E0E0', 
                                font: { 
                                    size: currentParams.tickSize, 
                                    family: CHART_FONT_FAMILY 
                                } 
                            }, 
                            grid: { color: '#555555' } 
                        },
                        y: { 
                            type: 'linear', 
                            title: { 
                                display: true, 
                                text: '平均VMAF', 
                                color: '#E0E0E0', 
                                font: { 
                                    size: currentParams.titleSize, 
                                    family: CHART_FONT_FAMILY 
                                } 
                            }, 
                            min: 60, max: 100, 
                            ticks: { 
                                color: '#E0E0E0', 
                                font: { 
                                    size: currentParams.tickSize, 
                                    family: CHART_FONT_FAMILY 
                                } 
                            }, 
                            grid: { color: '#555555' } 
                        }
                    }
                },
                plugins: [crosshairPlugin]
            });
            
            // 立即添加外部事件监听器，修复十字光标功能和 Tooltip 过滤依赖的坐标
            addCrosshairEvents(rateVMAFChart);
        }
        
        // -----------------------------------------------------------
        // 6. 控制逻辑 (更新后需调用 renderCustomLegend()) (保持不变)
        // -----------------------------------------------------------

        function getRowIndices(codec) {
            const indices = [];
            for (const platformKey of COLUMN_HEADERS) {
                const labels = ENCODER_MATRIX[codec][platformKey] || [];
                for (const label of labels) {
                    const dataset = chartDatasets.find(d => d.label === label);
                    // 仅添加有数据的曲线索引
                    if (dataset && dataset.data.length > 0) indices.push(dataset.datasetIndex);
                }
            }
            return indices;
        }

        function getColumnIndices(platformKey) {
            const indices = [];
            for (const codec of ROW_HEADERS) {
                const labels = ENCODER_MATRIX[codec][platformKey] || [];
                for (const label of labels) {
                    const dataset = chartDatasets.find(d => d.label === label);
                    // 仅添加有数据的曲线索引
                    if (dataset && dataset.data.length > 0) indices.push(dataset.datasetIndex);
                }
            }
            return indices;
        }

        /** 切换一行或一列的所有数据集 */
        function toggleGroup(indices, button) {
            if (!rateVMAFChart) return; 

            const isActive = button.classList.contains('active');
            const newState = !isActive; 

            indices.forEach(index => {
                rateVMAFChart.setDatasetVisibility(index, newState);
                
                const individualBtn = document.querySelector(`.control-button[data-index="${index}"]`);
                if (individualBtn) {
                    individualBtn.classList.toggle('active', newState);
                }
            });

            button.classList.toggle('active', newState);
            rateVMAFChart.update();
            renderCustomLegend(); // 更新自定义图例
        }

        /** 切换全部曲线 (全局按钮) */
        function toggleAllCurves() {
            if (!rateVMAFChart) return;

            const globalBtn = document.getElementById('globalShowAllBtn');
            const isActive = globalBtn.classList.contains('active');
            const newState = !isActive;

            rateVMAFChart.data.datasets.forEach((dataset, index) => {
                // 仅切换有数据的数据集
                if (dataset.data.length > 0) {
                    rateVMAFChart.setDatasetVisibility(index, newState);
                }
            });
            
            document.querySelectorAll('.control-button').forEach(btn => {
                if (!btn.classList.contains('no-data')) {
                    btn.classList.toggle('active', newState);
                }
            });
            
            document.querySelectorAll('.toggle-all-btn').forEach(btn => {
                const indices = btn.dataset.indices ? JSON.parse(btn.dataset.indices) : [];
                // 仅切换有数据的行/列开关
                if (indices.length > 0) {
                     btn.classList.toggle('active', newState);
                }
            });
            
            globalBtn.classList.toggle('active', newState);
            
            rateVMAFChart.update();
            renderCustomLegend(); // 更新自定义图例
        }

        /** 切换十字光标 */
        function toggleCrosshair() {
            if (!rateVMAFChart) return;

            const crosshairBtn = document.getElementById('toggleCrosshairBtn');
            const isActive = crosshairBtn.classList.contains('active');
            const newState = !isActive;
            
            // 切换插件的启用状态
            rateVMAFChart.options.plugins.customCrosshair.enabled = newState;
            rateVMAFChart.crosshairCoords = null; // 清除旧坐标
            
            crosshairBtn.classList.toggle('active', newState);
            
            // 确保禁用十字光标时，Tooltip 依然能够正常工作
            if (!newState) {
                // 重新触发 Chart.js 的内置交互逻辑
                rateVMAFChart.update(); 
            } else {
                // 启用十字光标时，隐藏 Tooltip
                rateVMAFChart.setActiveElements([]);
                rateVMAFChart.update();
            }
        }
        
        // -----------------------------------------------------------
        // 7. 保存图片逻辑 - 修正：统一宽度和添加间隙 (V4.0)
        // -----------------------------------------------------------
        
        // 用于触发下载的辅助函数
        function downloadURI(uri, name) {
            const link = document.createElement('a');
            link.download = name;
            link.href = uri;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        /**
         * 保存图片函数：渲染图表和图例，四倍超采样并裁剪。
         */
        async function saveImage() {
            const chartContainer = document.querySelector('.chart-container');
            const legendContainer = document.getElementById('customLegendContainer');
            
            // 1. 获取图表容器的实际宽度 (用于统一图表和图例的宽度)
            const chartWidth = chartContainer.offsetWidth; 
            const finalImagePadding = 20; // 最终截图内容周围的边距 (20px)

            // 确保截图前图表和图例处于最新的渲染状态
            rateVMAFChart.draw(); 
            renderCustomLegend();

            // 2. 克隆 Chart Container 和 Legend Container
            const clonedChartContainer = chartContainer.cloneNode(true);
            const clonedLegendContainer = legendContainer.cloneNode(true);
            
            // 3. 复制 Canvas 内容 (高分辨率)
            const originalCanvas = chartContainer.querySelector('canvas');
            const clonedCanvas = clonedChartContainer.querySelector('canvas');
            if (originalCanvas && clonedCanvas) {
                // 确保克隆的 canvas 尺寸与高分辨率绘制的原始 canvas 匹配
                clonedCanvas.width = originalCanvas.width;
                clonedCanvas.height = originalCanvas.height;
                const clonedCtx = clonedCanvas.getContext('2d');
                // 将原始的高分辨率内容绘制到克隆的 canvas 上
                clonedCtx.drawImage(originalCanvas, 0, 0); 
                // 恢复缩放，防止后续 html2canvas 渲染出错
                clonedCtx.scale(1 / Chart.defaults.devicePixelRatio, 1 / Chart.defaults.devicePixelRatio); 
            }
            
            // 4. 应用关键样式：显式复制边框、背景、内边距，并设置统一宽度
            const applyFinalStyles = (clonedEl, originalEl) => {
                // 关键修改: 强制统一宽度为图表容器的实际像素宽度
                clonedEl.style.width = `${chartWidth}px`; 
                clonedEl.style.maxWidth = 'none';
                clonedEl.style.margin = '0';
                clonedEl.style.boxSizing = 'border-box';
                
                // 2. 显式复制边框、背景、内边距样式 (确保 html2canvas 渲染)
                const style = getComputedStyle(originalEl);
                clonedEl.style.border = style.border;
                clonedEl.style.borderRadius = style.borderRadius;
                clonedEl.style.padding = style.padding;
                clonedEl.style.backgroundColor = style.backgroundColor;
                
                // 对于 chartContainer，需要修复 canvas 的父容器宽度以适应统一宽度
                if (clonedEl === clonedChartContainer) {
                     const canvasEl = clonedEl.querySelector('canvas');
                     if (canvasEl) {
                        // 确保 canvas 宽度保持不变 (aspect-ratio: 1 依赖这个)
                        canvasEl.style.width = style.width;
                        canvasEl.style.height = style.height;
                     }
                }
            };
            
            applyFinalStyles(clonedChartContainer, chartContainer);
            applyFinalStyles(clonedLegendContainer, legendContainer);


            // 5. 创建截图根容器 (TempDiv)，用于居中、间隙和添加边距
            const tempDiv = document.createElement('div');
            tempDiv.id = 'screenshot-root';
            // 使用 Flex 布局垂直堆叠，并实现居中
            tempDiv.style.display = 'flex';
            tempDiv.style.flexDirection = 'column';
            tempDiv.style.alignItems = 'center'; // 水平居中
            tempDiv.style.gap = '10px'; // **关键修改: 添加 10px 垂直间隙**
            tempDiv.style.padding = `${finalImagePadding}px`; // 四周添加边距
            tempDiv.style.backgroundColor = getComputedStyle(document.body).backgroundColor;
            tempDiv.style.position = 'absolute'; // 确保它不影响页面布局
            tempDiv.style.top = '0';
            tempDiv.style.left = '0';
            tempDiv.style.width = 'fit-content'; // 让根容器紧贴内容 (由子元素统一宽度)

            // 6. 组织结构: 克隆元素作为子元素添加到 tempDiv
            tempDiv.appendChild(clonedChartContainer);
            tempDiv.appendChild(clonedLegendContainer);
            
            document.body.appendChild(tempDiv);
            
            // 7. 执行截图
            try {
                const canvas = await html2canvas(tempDiv, {
                    scale: 4, // 4x 超采样
                    backgroundColor: getComputedStyle(document.body).backgroundColor,
                    // 不指定 width/height，让 html2canvas 自动计算 tempDiv 的尺寸
                    useCORS: true 
                });

                // 8. 转换为 PNG 并下载
                const dataURL = canvas.toDataURL('image/png');
                const filename = `Encoder_Perf_Curve.png`; // 固定文件名
                downloadURI(dataURL, filename);

            } catch (error) {
                console.error('保存图片失败:', error);
                alert('保存图片失败，请检查控制台了解详情。');
            } finally {
                // 9. 移除临时容器
                document.body.removeChild(tempDiv);
            }
        }


        // -----------------------------------------------------------
        // 8. 表格构建 (DOM操作) (保持不变)
        // -----------------------------------------------------------
        document.addEventListener('DOMContentLoaded', () => {
            const controlsTable = document.getElementById('controlsTable');
            
            // 1. 初始化 Chart
            initializeChart();

            // 2. 首次渲染自定义图例 (在表格加载前)
            renderCustomLegend();

            // 3. 生成表头 (左上角留空)
            let headerHtml = '<thead><tr><th></th>'; 
            COLUMN_HEADERS.forEach(header => { headerHtml += `<th>${header}</th>`; });
            headerHtml += `<th>行开关</th></tr></thead><tbody>`;
            controlsTable.innerHTML = headerHtml;


            // 4. 生成表格内容
            ROW_HEADERS.forEach(codec => {
                const row = controlsTable.insertRow();
                const headerCell = row.insertCell();
                headerCell.innerHTML = `<strong>${codec}</strong>`; 

                COLUMN_HEADERS.forEach(platformKey => {
                    const cell = row.insertCell();
                    const datasetLabels = ENCODER_MATRIX[codec][platformKey];
                    
                    if (datasetLabels && datasetLabels.length > 0) {
                        const container = document.createElement('div');
                        container.className = 'cell-container';

                        datasetLabels.forEach(label => {
                            const dataset = chartDatasets.find(d => d.label === label);
                            if (dataset) {
                                const button = document.createElement('div');
                                button.textContent = dataset.simplifiedName;
                                button.dataset.index = dataset.datasetIndex; 

                                const hasData = dataset.data.length > 0;
                                button.classList.add('control-button');

                                if (hasData) {
                                    button.classList.add('active'); 
                                    const colorIndicator = document.createElement('span');
                                    colorIndicator.className = 'color-indicator';
                                    
                                    // 模拟 Chart.js 点样式
                                    colorIndicator.style.backgroundColor = dataset.backgroundColor; 
                                    colorIndicator.style.borderColor = dataset.color; 
                                    
                                    button.appendChild(colorIndicator);

                                    button.addEventListener('click', function() {
                                        const index = parseInt(this.dataset.index);
                                        const isVisible = rateVMAFChart.isDatasetVisible(index);
                                        
                                        rateVMAFChart.setDatasetVisibility(index, !isVisible);
                                        rateVMAFChart.update();
                                        this.classList.toggle('active', !isVisible);
                                        renderCustomLegend(); // 更新自定义图例
                                    });
                                } else {
                                    // 无数据的按钮
                                    button.classList.add('no-data');
                                    button.textContent += ' —'; 
                                }
                                container.appendChild(button);
                            }
                        });
                        
                        if (container.children.length === 0) {
                            const noDataCell = document.createElement('div');
                            noDataCell.className = 'no-data-cell';
                            noDataCell.textContent = '—';
                            cell.appendChild(noDataCell);
                        } else {
                            cell.appendChild(container);
                        }

                    } else {
                        const noDataCell = document.createElement('div');
                        noDataCell.className = 'no-data-cell';
                        noDataCell.textContent = '—';
                        cell.appendChild(noDataCell);
                    }
                });

                // 行开关列 - 使用统一间隙的容器
                const toggleCell = row.insertCell();
                const indices = getRowIndices(codec);
                
                const toggleContainer = document.createElement('div');
                toggleContainer.className = 'toggle-cell-container';

                if (indices.length > 0) {
                    const toggleBtn = document.createElement('div');
                    toggleBtn.className = 'toggle-all-btn active'; 
                    toggleBtn.textContent = '全部';
                    toggleBtn.dataset.indices = JSON.stringify(indices); 
                    toggleBtn.addEventListener('click', function() {
                        toggleGroup(indices, this);
                    });
                    toggleContainer.appendChild(toggleBtn);
                    toggleCell.appendChild(toggleContainer);
                } else {
                    const noDataCell = document.createElement('div');
                    noDataCell.className = 'no-data-cell';
                    noDataCell.textContent = '—';
                    toggleCell.appendChild(noDataCell);
                }
            });

            // 5. 插入列开关行 (表尾)
            const footerRow = controlsTable.insertRow();
            const footerHeaderCell = footerRow.insertCell();
            footerHeaderCell.innerHTML = '<strong>列开关</strong>'; 
            
            COLUMN_HEADERS.forEach(platformKey => {
                const cell = footerRow.insertCell();
                const indices = getColumnIndices(platformKey);
                
                const toggleContainer = document.createElement('div');
                toggleContainer.className = 'toggle-cell-container';

                if (indices.length > 0) {
                    const toggleBtn = document.createElement('div');
                    toggleBtn.className = 'toggle-all-btn active'; 
                    toggleBtn.textContent = '全部';
                    toggleBtn.dataset.indices = JSON.stringify(indices); 
                    toggleBtn.addEventListener('click', function() {
                        toggleGroup(indices, this);
                    });
                    toggleContainer.appendChild(toggleBtn);
                    cell.appendChild(toggleContainer);
                } else {
                    const noDataCell = document.createElement('div');
                    noDataCell.className = 'no-data-cell';
                    noDataCell.textContent = '—';
                    cell.appendChild(noDataCell);
                }
            });
            
            // 6. 最后一个单元格留空
            const lastCell = footerRow.insertCell();
            const noDataCellEnd = document.createElement('div');
            noDataCellEnd.className = 'no-data-cell';
            noDataCellEnd.textContent = '—';
            lastCell.appendChild(noDataCellEnd);

            
            // 7. 绑定全局按钮事件
            const globalBtn = document.getElementById('globalShowAllBtn');
            globalBtn.addEventListener('click', toggleAllCurves);
            
            const crosshairBtn = document.getElementById('toggleCrosshairBtn');
            crosshairBtn.addEventListener('click', toggleCrosshair);

            // [新增加] 绑定保存图片按钮事件
            const saveImageBtn = document.getElementById('saveImageBtn');
            saveImageBtn.addEventListener('click', saveImage);
        });
    </script>

</body>
</html>